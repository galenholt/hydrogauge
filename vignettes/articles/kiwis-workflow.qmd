---
title: "KiWIS workflow"
format: 
  html:
    toc: true
vignette: >
  %\VignetteIndexEntry{Base-hydstra-workflow}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r}
#| include: false
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r}
library(hydrogauge)
library(ggplot2)
```

At present, we largely assume the user will have a list of gauges they want. The KiWIS interface does provide some opportunity to programatically find gauge numbers according to criteria, using [getParameterList()], [getGroupList()], and [getStationList()] (most useful). This vignette, however, assumes we have selected a set of gauges and want to identify variables and pull their timeseries. For experimental wrappers that abstract some of this, see [their vignette](kiwis-wrapper.qmd).

Unlike Hydstra, which provides tailored arguments for different sorts of API control, KiWIS primarily uses text search within columns. This can be more flexible, but means we need to know column names and pay close attention to the regex used to filter those columns to avoid contaminating outputs. This generality means that no column is favoured over others in filtering, and hydrogauge provides access to the full search capability with the `extra_list` argument. However, we also make a concession for consistency by making `station_no` its own argument, corresponding to the `site_list` argument in Hydstra.  

To get timeseries, the user needs to ask for specific variables and timespans. Sometimes these are known *a priori*, e.g. if a gauge was chosen because it is known to have flow for a desired period. However, finding available variables and their periods of record can also be done through the functions here, primarily [getTimeseriesList()]. This is one of the main purposes of this package; we want to be able to query available data.

Due to the search functionality of the KiWIS interface, we can use gauge numbers as we do with hydstra, but we can also search more generally. Note also that this returns a very large list, primarily due to the values in `ts_id` and `ts_name` colummns, which arise because the various types of data and aggregations are given unique values there, rather than being calculated.

```{r}
station_tslist <- getTimeseriesList(portal = 'bom', station_no = c('410730', 'A4260505'))

station_tslist
```

We can take advantage of the search capability to ignore gauge numbers entirely, and get all sites meeting some regex pattern, here those with `'River Murray'` in the `station_name`. We do this with the `extra_list` argument, which takes column names as names and the seach pattern as the item, which also allows us here to only look at the DMQaQc data at a Daily Mean aggregation. The `returnfields` lets us choose which columns to return.

```{r}
RM_ts <- getTimeseriesList(portal = 'bom',
                           extra_list = list(station_name = 'River Murray*',
                                             ts_name = 'DMQaQc.Merged.DailyMean.24HR'),
                           returnfields = c('station_no', 'station_name',
                                            'ts_name', 'ts_id', 
                                            'ts_unitname', 'parametertype_name'))

RM_ts
```

The available returnfields are poorly documented. The default are those returned above for `station_tslist`, 

```{r}
names(station_tslist)[!names(station_tslist) %in% c('from', 'to', 'database_timezone')]
```
But there are others that can be requested. 
```{r}
  # According to kisters, these exist
  all_return <- c('station_name', 'station_latitude', 'station_longitude', 'station_carteasting', 'station_cartnorthing', 'station_local_x', 'station_local_y', 'station_georefsystem', 'station_longname', 'ts_id', 'ts_name', 'ts_shortname', 'ts_path', 'ts_type_id', 'ts_type_name', 'parametertype_id', 'parametertype_name', 'stationparameter_name', 'stationparameter_no', 'stationparameter_longname', 'ts_unitname', 'ts_unitsymbol', 'ts_unitname_abs', 'ts_unitsymbol_abs', 'site_no', 'site_id', 'site_name', 'catchment_no', 'catchment_id', 'catchment_name', 'coverage', 'ts_density', 'ts_exchange', 'ts_spacing', 'ts_clientvalue##', 'datacart', 'ca_site', 'ca_sta', 'ca_par', 'ca_ts')
  # I get http 500 errors unless I cut to
  sub_return <- all_return[c(1:34, 37:40)]
  sub_return
```
