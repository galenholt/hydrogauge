---
vignette: >
  %\VignetteIndexEntry{hydstra_flow}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(hydrogauge)
library(ggplot2)
```


At present, we largely assume the user will have a list of gauges they want, as the current ability to programatically obtain gauge numbers according to criteria is limited (but see [get_sites_by_datasource()], which allows asking for all sites that have a given datasource).


To get timeseries, the user needs to ask for specific variables and timespans. Sometimes these are known *a priori*, e.g. if a gauge was chosen because it is known to have flow for a desired period. However, finding available variables and their periods of record can also be done through the functions here. This is one of the main purposes of this package; we want to be able to query available data.

This vignette will proceed with a set of sites chosen to span a range of characteristics useful for this demonstration.

-   The Upper Steavenson (405328) only has flow

-   Barwon (233217) has many variables, but their start dates differ

-   Taggerty (405331) is no longer in operation- ran 2010-2013

-   Marysville golf course (405837) is only rainfall

The functions all require gauges to be their numeric codes as characters. The API needs a comma-separated string (`"number1, number2"` ) , but the functions here will accept a vector `c("number1", "number2"`) and decompose it internally. This is typically easier and reflects more common R workflows such as having a column of site numbers in a dataframe.

```{r}
barwon <- '233217'
steavenson <- '405328'
taggerty <- '405331'
golf <- '405837'
```

# Querying available data

Before asking for timeseries data, we want to ask what data is available. we use  

## Finding datasources

To see what datasources are available for a site, use [get_datasources_by_site()]. I typically use "A", but it's worth looking to see what datasources are available for a target site(s), and then doing the next step (finding variables) for each, to see whether the available variables (or timeperiods) differ. *Note- there are often other datasources that work but are not returned here.*

```{r}
ds <- get_datasources_by_site(portal = 'Vic', 
                              site_list = c(barwon, steavenson, 
                                            taggerty, golf))
```

```{r rows.print = 15}
ds
```

Plot that to see data availability (@fig-datasource).

```{r}
#| label: fig-datasource
#| fig-cap: Datasources available for each gauge. These are what are returned by the API, but may not be complete. Specifying other datasources on a pull may work.
plot_datasources_by_site(ds)
```
## Finding available variables

We then need to know what variables are available to extract timeseries of. We use [get_variable_list()] to get this information, including both their names and numbers, as well as other details such as the time period of record and units.

```{r}
var_info <- get_variable_list(portal = 'Vic', 
                              site_list = c(barwon, taggerty, 
                                            steavenson, golf), 
                              datasource = "A")
```

That returns a tibble with information about each gauge and variable (@tbl-vars). A few things to note- it gives the names of the gauges, the names and values of the variables, and a start and end date for each. For example, the Barwon's start date for stage (100) is 1961, while the others (pH, ppm, etc) didn't start until 2010.

*Note that this does **not** return derived discharge variables (140 and 141)*. If variable 100 (stage height) exists, the other two usually do, though sometimes not if there is no ratings curve.

```{r}
#| label: tbl-vars
#| tbl-cap: Variables available and period of record for target gauges
#| rows.print: 15 
var_info
```

Depending on the goals, it can be helpful to visualise this as the availability of each variable (@fig-vars-duration) or the period of record of each variable (@fig-vars-period).

```{r}
#| label: fig-vars-duration
#| fig-cap: Availability of each variable at each gauge, with color indicating the duration of record in days.
var_info |> 
  dplyr::mutate(duration = period_end-period_start) |> 
ggplot(aes(x = var_name, y = site, fill = duration)) +
  geom_tile() +
  scale_fill_viridis_c(option = 'plasma') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
```{r}
#| label: fig-vars-period
#| fig-cap: Availability of each variable at each gauge, with the period of record indicated by lines.
var_info |> 
  tidyr::pivot_longer(cols = starts_with('period'), names_to = 'startend', values_to = 'date') |> 
ggplot(aes(y = date, x = site, color = var_name)) +
  geom_point(position = position_dodge(width = 0.5)) + geom_line(position = position_dodge(width = 0.5)) +
  coord_flip()
```

# Obtaining timeseries

This is typically the main goal, with the other steps getting us to the point of knowing what to ask for. Specifically, [get_variable_list()] gives us a reference to know what the variables are to ask for and the relevant timeperiods.

## Basic operation

In general, we use [get_ts_traces()] for a set of sites, variables, timeperiods, and statistics. The experimental wrapper functions [fetch_hydstra_timeseries()] and [fetch_timeseries()] call [get_ts_traces()] internally. In any case, there are some pitfalls to avoid.

If we just want a set of variables that all need the same statistic applied (e.g. daily mean flows), we can pass that in as a vector. For example, to get daily mean stage height (100), discharge (here in ML/day, 141), and temperature (450), we can do that in one call, even for multiple gauges. Asking here for only 5 days to keep the call quick.

```{r}
ts_days <- get_ts_traces(portal = 'Vic', 
                         site_list = c(barwon, steavenson, taggerty, golf),
                         datasource = "A", 
                         var_list = c("100", "141", "450"),
                         start_time = 20200101,
                         end_time = 20201231,
                         interval = "day",
                         data_type = "mean",
                         multiplier = 1,
                         returnformat = 'df')
```

That returns a tall dataframe with boththe requested values and some site metadata including the site name, location, etc (@tbl-ts), which the user can then split up or plot how they want (e.g. @fig-ts). There are other options that return lists of dataframes if the user does not want all sites and variables combined-

-   `returnformat = "varlist"` a list with one tibble per variable

-   `returnformat = "sitelist"` a list with one tibble per site

-   `returnformat = "sxvlist"` a list with one tibble per site x variable combo (including empty lists for missing combos)

```{r}
#| label: tbl-ts
#| tbl-cap: Head of returned timeseries
# rows.print doesn't really work with devtools::build_readme(), so use head
head(ts_days, 30)
```

```{r}
#| label: fig-ts
#| fig-cap: Timeseries of requested data, where available.
ts_days |> 
  ggplot(aes(x = time, y = value, color = variable_short_name)) +
  geom_line() +
  facet_grid(variable_short_name ~ site_short_name, scales = 'free')
```


Note that if a variable isn't available for a gauge it just isn't returned, and same with timeperiods. We requested data from all four sites, but only the Barwon returns all variables. The golf course gauge does not return anything because it does not collect these variables, the Steavenson returns level and discharge but not temp, and the Taggerty doesn't appear at all despite having these variables because we've asked for data after it was decommissioned.

## Multiple variables, multiple statistics

Now, if we want another set of variables that should have a different statistic (e.g. rainfall makes sense as the daily sum, not the mean), we need a separate call to [get_ts_traces()] with a different `data_type` argument.

Note that again this will ignore gauges without the info (@tbl-ts-rain, @fig-ts-rain).

```{r}
ts_rain <- get_ts_traces(portal = 'Vic', 
                         site_list = c(barwon, golf), 
                         datasource = "A", 
                         var_list = c("10"),
                         start_time = 20200101,
                         end_time = 20201231,
                         interval = "day",
                         data_type = "tot",
                         multiplier = 1,
                         returnformat = 'df')
```

```{r}
#| label: tbl-ts-rain
#| tbl-cap: Head of returned rainfall timeseries
head(ts_rain, 30)
```

```{r}
#| label: fig-ts-rain
#| fig-cap: Timeseries of rainfall data, where available.
ts_rain |> 
  ggplot(aes(x = time, y = value, color = variable_short_name)) +
  geom_line() +
  facet_grid(variable_short_name ~ site_short_name, scales = 'free')
```

If the user wants to combine across different statistics, use [dplyr::bind_rows()] to combine post-hoc.

An automated approach that can simplify some common workflows (especially pulling period of record for many gauges) is available in [fetch_hydstra_timeseries()], but care must be taken to avoid inappropriate statistics.

# Experimental wrapper

The [fetch_hydstra_timeseries()] function wraps [get_variable_list()] and [get_ts_traces()], which allows some extra functionality and smoother workflows but also introduces some danger and sometimes inefficiency. Some argument names have been changed compared to [get_ts_traces()] (which uses the Kisters names nearly verbatim) for more clarity and to move towards a unified interface across both API styles.

This function allows requests for the full period of record by passing `'all'` for the `start_time` and `end_time` (or the earliest and latest possible dates, respectively). The downside of this approach is that the calls to the API are inefficient (each row is called separately), though this is also necessarily the case if asking for the period of record manually for gauges with different periods. It will be possible to do some inferences and combinations here, but it has not been high priority. 

This function is most useful when we want to pull the period of record of the same variable for a set of gauges. For example, we might want to pull discharge for the period of record, which we can do by passing `'all'` to `start_time` and `end_time`, yielding @fig-discharge-period.

```{r}
discharge_record <- fetch_hydstra_timeseries(portal = 'vic', 
                                       gauge = c(barwon, steavenson, taggerty),
                                       var_list = '141',
                                       start_time = 'all',
                                       end_time = 'all',
                                       timeunit = 'day',
                                       statistic = 'mean')
```

```{r}
#| label: fig-discharge-period
#| fig-cap: Discharge for the period of record for three gauges.
discharge_record |> 
  ggplot(aes(x = time, y = value, color = site_short_name)) +
  geom_line() +
  facet_grid(site_short_name~., scales = 'free_y') +
  labs(y = unique(discharge_record$variable_short_name))
```
We can also pull data for all available variables by passing `'all'` to `var_list`. *DANGER: if `var_type = 'all'`, the same statistic will be applied to all variables.* Calling `'all'` for the `start_time` and `'end_time'` *will* give each variable a different period of record if they differ; the times are found from each row returned by [get_variable_list()]. 

For the sake of demonstration, we make the bad choice here of getting all the data, summarised in @tbl-all. This throws a warning because it's a bad idea in general.

```{r}
all_vars_fullperiod <- fetch_hydstra_timeseries(portal = 'vic', 
                                       gauge = c(barwon, golf),
                                       var_list = 'all',
                                       start_time = 'all',
                                       end_time = 'all',
                                       timeunit = 'day',
                                       statistic = 'mean')
```
```{r}
#| label: tbl-all
#| tbl-cap: Number of records for the period of record pulled by code above. Note that the Rainfall measurements will be daily means, which is not appropriate.
#| 
all_vars_fullperiod |> 
  dplyr::summarise(n_records = dplyr::n(), 
                   .by = c(site_short_name, variable_short_name, statistic)) |> 
  knitr::kable()
```

We *can* request different statistics for different variables if the variables are passed in as a vector of arguments to `var_list`, though then you have to know what they are. In that case, the `statistic` argument should be a vector of matched length to `var_list`.

Let's ask for the period of record for daily mean discharge, total daily rainfall, and maximum daily temperature in the Barwon (233217), which returns different statistics for each variable (@tbl-diffstats).

```{r}
different_statistics <- fetch_hydstra_timeseries(portal = 'vic', 
                                       gauge = c(barwon, golf),
                                       var_list = c('141', '10', '450'),
                                       start_time = 'all',
                                       end_time = 'all',
                                       timeunit = 'day',
                                       statistic = c('mean', 'tot', 'max'))
```

```{r}
#| label: tbl-diffstats
#| tbl-cap: Number of records for the period of record pulled by code above. By using a vector of statistics matching the vector of var_list, we can use different statistics for each variable.
#| 
different_statistics |> 
  dplyr::summarise(n_records = dplyr::n(), 
                   .by = c(site_short_name, variable_short_name, statistic)) |> 
  knitr::kable()
```

We can also use the `variable` and `unit` arguments instead of `var_list` to search for variables by name, as in `fetch_kiwis_timeseries`. This is very experimental, moving towards a unified wrapper. We can use this to recapitulate the pull of discharge for the gauges (@fig-discharge-byname).

```{r}
by_name <- fetch_hydstra_timeseries(portal = 'vic', 
                                       gauge = c(barwon, steavenson, taggerty),
                                       variable = 'discharge',
                                       unit = 'ML/d',
                                       start_time = 'all',
                                       end_time = 'all',
                                       timeunit = 'day',
                                       statistic = 'mean')
```

```{r}
#| label: fig-discharge-byname
#| fig-cap: Discharge for the period of record for three gauges, obtained by name.
by_name |> 
  ggplot(aes(x = time, y = value, color = site_short_name)) +
  geom_line() +
  facet_grid(site_short_name~., scales = 'free_y') +
  labs(y = unique(by_name$variable_short_name))
```

## Large requests

*Note: with big pulls, it can be useful to recommended to use the bare [get_variable_list()] and [get_ts_traces()] approach, or at least a manual check of [get_variable_list()].* In my experience, there are often errors with some gauges or other issues that mean clean pulls need some troubleshooting of the variable availability etc. It is often easiest to find and solve problems at the low-level API interface. Making [fetch_hydstra_timeseries()] incorporate some of this is in development.

# Other portals

Most examples use Victorian water data, but this should work wherever we have a link to a hydstra API. 

At the most basic, we can use a raw https path, demonstrated with Victoria,

```{r}
ds_http <- get_datasources_by_site(portal = 'https://data.water.vic.gov.au/WMIS/cgi/webservice.exe?', 
                              site_list = c(barwon, steavenson, 
                                            taggerty, golf))
```

```{r rows.print = 15}
ds_http
```

In theory, that should work with any Hydstra source, many of which are listed by [Kisters](https://resources.kisters.com.au/public/kisters-web-publishing/). The catch is, finding the API path is not always straightforward. For example, this *should* work for [Washington Department of Ecology](https://apps.ecology.wa.gov/continuousflowandwq/), [California department of water resources](https://wdl.water.ca.gov/waterdatalibrary/), and [Western Australia](https://kumina.water.wa.gov.au/waterinformation/telem/stage.cfm), but none of those addresses work. Either those orgs don't publish their APIs, or there are undiscovered '.../webservice.exe?' paths there waiting to be discovered and used.  

In addition to Victoria, New South Wales and Queensland have public portals and are available by name as `portal` arguments. To demonstrate, we can use `get_datasources_by_site` to see what datasources are available (note the major differences between the states):

```{r}
nsw_ds <- get_datasources_by_site(portal = 'NSW', 
                                  site_list = c("422028", "410007"))
```

```{r}
nsw_ds
```

```{r}
qld_ds <- get_datasources_by_site(portal = 'QLD', 
                                  site_list = c("423203A", "424201A"))
```

```{r}
qld_ds
```

## Traces and plots

### NSW

Now we can `get_ts_traces` for `A`, just to keep things consistent

```{r}
nsw_ts_days <- get_ts_traces(portal = 'NSW', 
                         site_list = c("422028", "410007"),
                         datasource = "A", 
                         var_list = c("100", "141", "450"),
                         start_time = 20200101,
                         end_time = 20201231,
                         interval = "day",
                         data_type = "mean",
                         multiplier = 1,
                         returnformat = 'df')

```

```{r}
ggplot(nsw_ts_days, aes(x = time, y = value, color = site_short_name)) + 
  facet_wrap(~variable_short_name, scales = 'free') + 
  geom_line()
```

### QLD


```{r}
qld_ts_days <- get_ts_traces(portal = 'QLD', 
                         site_list = c("423203A", "424201A"),
                         datasource = "A", 
                         var_list = c("100", "141", "450"),
                         start_time = 20200101,
                         end_time = 20201231,
                         interval = "day",
                         data_type = "mean",
                         multiplier = 1,
                         returnformat = 'df')

```

```{r}
ggplot(qld_ts_days, aes(x = time, y = value, color = site_short_name)) + 
  facet_wrap(~variable_short_name, scales = 'free') + 
  geom_line()
```

